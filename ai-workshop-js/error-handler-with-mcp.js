const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * Enhanced error handler that uses MCP browser automation to assign Copilot
 * This is a drop-in replacement for error-handler.js
 */

class ErrorHandlerWithMCP {
  constructor(options = {}) {
    this.enabled = options.enabled !== false;
    this.rateLimitMinutes = options.rateLimitMinutes || 5;
    this.recentIssues = new Map();
    this.appState = {};
    this.useMCP = options.useMCP || false; // Enable MCP automation
    
    if (this.enabled) {
      this.setupGlobalHandlers();
    }
  }

  // ... [Include all the existing methods from error-handler.js] ...

  async createGitHubIssue(errorReport) {
    const title = `[Auto-Generated] ${errorReport.error.name}: ${errorReport.error.message}`;
    const body = this.formatIssueBody(errorReport);
    
    try {
      // Create temporary markdown file for issue body
      const tempFile = path.join(process.cwd(), `issue-${Date.now()}.md`);
      fs.writeFileSync(tempFile, body);
      
      // Create the issue using GitHub CLI
      const createCommand = `gh issue create --title "${this.escapeShellArg(title)}" --body-file "${tempFile}"`;
      const result = execSync(createCommand, { encoding: 'utf-8' });
      
      const issueUrl = result.trim();
      console.log(`[ErrorHandler] Created issue: ${issueUrl}`);
      
      // Extract issue number
      const issueMatch = issueUrl.match(/\/issues\/(\d+)$/);
      if (issueMatch && this.useMCP) {
        const issueNumber = issueMatch[1];
        
        // Generate MCP automation code
        const mcpCode = this.generateMCPAssignmentCode(issueUrl);
        
        // Save MCP code for execution
        const mcpFile = path.join(process.cwd(), `mcp-assign-${issueNumber}.js`);
        fs.writeFileSync(mcpFile, mcpCode);
        
        console.log(`[ErrorHandler] MCP assignment code saved to: ${mcpFile}`);
        console.log(`[ErrorHandler] To assign Copilot, execute the MCP commands in the file`);
        
        // If we're in an environment that can execute MCP directly, do it
        if (global.mcp__playwright__browser_navigate) {
          console.log(`[ErrorHandler] Executing MCP automation...`);
          await this.executeMCPAssignment(issueUrl);
        }
      }
      
      // Clean up temp file
      fs.unlinkSync(tempFile);
      
      return issueUrl;
      
    } catch (error) {
      console.error('[ErrorHandler] Failed to create GitHub issue:', error.message);
      
      // Clean up temp files
      const tempFiles = fs.readdirSync(process.cwd()).filter(f => f.startsWith('issue-') && f.endsWith('.md'));
      tempFiles.forEach(f => {
        try {
          fs.unlinkSync(path.join(process.cwd(), f));
        } catch (e) {
          // Ignore cleanup errors
        }
      });
    }
  }

  generateMCPAssignmentCode(issueUrl) {
    return `
// MCP Browser Automation for Copilot Assignment
// Generated by ErrorHandler for: ${issueUrl}

async function assignCopilot() {
  // Navigate to issue
  await mcp__playwright__browser_navigate({ url: "${issueUrl}" });
  
  // Wait for page load
  await new Promise(resolve => setTimeout(resolve, 3000));
  
  // Click assignees button
  await mcp__playwright__browser_click({
    element: "Assignees settings button",
    ref: "button[aria-label='Select assignees']"
  });
  
  // Wait for dropdown
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Type Copilot
  await mcp__playwright__browser_type({
    element: "Assignee search field",
    ref: "input[placeholder*='Search']",
    text: "Copilot"
  });
  
  // Wait for results
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  // Click Copilot option
  await mcp__playwright__browser_click({
    element: "Copilot option",
    ref: "div[role='option']:has-text('Copilot')"
  });
  
  // Close dropdown
  await mcp__playwright__browser_click({
    element: "Page body",
    ref: "body"
  });
  
  console.log("Copilot assigned successfully!");
}

// Execute if MCP tools are available
if (typeof mcp__playwright__browser_navigate !== 'undefined') {
  assignCopilot().catch(console.error);
} else {
  console.log("MCP tools not available. Please run this in an MCP-enabled environment.");
}
`;
  }

  async executeMCPAssignment(issueUrl) {
    try {
      // This function would be called when MCP tools are available
      await mcp__playwright__browser_navigate({ url: issueUrl });
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      await mcp__playwright__browser_click({
        element: "Assignees settings button",
        ref: "button[aria-label='Select assignees']"
      });
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await mcp__playwright__browser_type({
        element: "Assignee search field",
        ref: "input[placeholder*='Search']",
        text: "Copilot"
      });
      
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      await mcp__playwright__browser_click({
        element: "Copilot option",
        ref: "div[role='option']:has-text('Copilot')"
      });
      
      await mcp__playwright__browser_click({
        element: "Page body",
        ref: "body"
      });
      
      console.log('[ErrorHandler] Successfully assigned Copilot via MCP');
    } catch (error) {
      console.error('[ErrorHandler] MCP assignment failed:', error.message);
    }
  }

  // Copy all other methods from original error-handler.js
  setupGlobalHandlers() {
    // ... existing code ...
  }

  wrapFunction(fn, context = '') {
    // ... existing code ...
  }

  updateContext(newState) {
    this.appState = { ...this.appState, ...newState };
  }

  async handleError(error, source, additionalContext = {}) {
    // ... existing code ...
  }

  getErrorKey(error) {
    const stack = error.stack || '';
    const firstStackLine = stack.split('\\n')[1] || '';
    return `${error.message}-${firstStackLine}`.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 100);
  }

  isRateLimited(errorKey) {
    const lastReported = this.recentIssues.get(errorKey);
    if (!lastReported) return false;
    
    const now = Date.now();
    const timeDiff = now - lastReported;
    const rateLimitMs = this.rateLimitMinutes * 60 * 1000;
    
    return timeDiff < rateLimitMs;
  }

  captureErrorState(error, source, additionalContext) {
    const timestamp = new Date().toISOString();
    
    return {
      timestamp,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
        source
      },
      context: {
        ...this.appState,
        ...additionalContext,
        nodeVersion: process.version,
        platform: process.platform,
        workingDirectory: process.cwd(),
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
      },
      environment: {
        NODE_ENV: process.env.NODE_ENV,
        npm_package_name: process.env.npm_package_name,
        npm_package_version: process.env.npm_package_version
      }
    };
  }

  formatIssueBody(errorReport) {
    const { error, context, environment, timestamp } = errorReport;
    
    const errorName = error.name || 'UnknownError';
    const errorMessage = error.message || 'No error message provided';
    const errorStack = error.stack || 'No stack trace available';
    const errorSource = error.source || 'unknown';
    
    const nodeVersion = context.nodeVersion || 'Unknown';
    const platform = context.platform || 'Unknown';
    const workingDir = context.workingDirectory || 'Unknown';
    const memoryUsage = context.memoryUsage ? JSON.stringify(context.memoryUsage, null, 2) : 'Not available';
    const uptime = context.uptime || 0;
    
    const cleanContext = { ...context };
    delete cleanContext.nodeVersion;
    delete cleanContext.platform;
    delete cleanContext.workingDirectory;
    delete cleanContext.memoryUsage;
    delete cleanContext.uptime;
    
    return `## 🐛 Automatic Error Report

**Timestamp:** ${timestamp}  
**Source:** ${errorSource}  
**Error Type:** ${errorName}  

### Error Details

**Message:**
\`\`\`
${errorMessage}
\`\`\`

### Stack Trace
\`\`\`javascript
${errorStack}
\`\`\`

### Environment Information

| Property | Value |
|----------|-------|
| **Node Version** | ${nodeVersion} |
| **Platform** | ${platform} |
| **Working Directory** | \`${workingDir}\` |
| **Process Uptime** | ${uptime.toFixed(2)}s |

**Memory Usage:**
\`\`\`json
${memoryUsage}
\`\`\`

### Application Context

\`\`\`json
${JSON.stringify(cleanContext, null, 2)}
\`\`\`

### Environment Variables

<details>
<summary>Click to expand environment variables</summary>

\`\`\`json
${JSON.stringify(environment, null, 2)}
\`\`\`

</details>

---

## 🤖 Instructions for @Copilot

Please help resolve this automatically generated error report by following these steps:

1. **Analyze the Error**: Review the stack trace and context to understand the root cause
2. **Create a Failing Test**: Write a test that reproduces this error
3. **Implement the Fix**: Create a solution that resolves the issue
4. **Create a Pull Request**: Submit your changes with:
   - The failing test demonstrating the bug
   - The fix that makes the test pass
   - Clear explanation of the solution

### Suggested Investigation Areas:
- Check for null/undefined values in the stack trace
- Verify error handling in async operations
- Look for missing validation or edge cases
- Consider defensive programming improvements

**Priority:** High - Automatic error detection indicates real user impact

---

*This issue was automatically generated by the ErrorHandler system*`;
  }

  escapeShellArg(arg) {
    return arg.replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
  }

  cleanup() {
    const now = Date.now();
    const rateLimitMs = this.rateLimitMinutes * 60 * 1000;
    
    for (const [key, timestamp] of this.recentIssues.entries()) {
      if (now - timestamp > rateLimitMs) {
        this.recentIssues.delete(key);
      }
    }
  }
}

module.exports = ErrorHandlerWithMCP;